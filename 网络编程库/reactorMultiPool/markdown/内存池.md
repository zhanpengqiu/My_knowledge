# 为什么使用内存池
1. 避免内存碎片。
2. 避免系统调用开销。

操作系统分**用户态**和**内核态**，我们只能在用户态进行操作。我们所使用的内存有栈和堆的，栈的内存自动分配和回收。对于程序员来说，主动申请和释放的内存是堆的内存。比如 `malloc()`、`free()`。
我们调用 `malloc()` 向堆申请内存，系统也分配给了我们。但是我们申请的这部分内存容易造成内部碎片，这会导致残缺的内存块不能被我们所利用。比如申请 4k 的内存块，系统剩余的内存空间也够。但是这些是不连续的，连续的块可能只有 2k 大小，那么就会发生内存分配失败的情况。
如果是公司级别的程序，不像个人写的 demo。那么随着服务器长久时间的运行，可能会出现不断蚕食剩余内存的情况，这种内存问题很难排查。
除此之外，malloc 是会涉及用户态和内核态转换的。经常这样转换会影响服务器性能，我们应尽量避免直接向系统申请内存。
因此我们需要内存池来解决上述问题，本质就是程序员自己设置一套管理内存的手段。我们向系统申请大块的内存并交由内存池来管理，编程中对应内存的申请和释放就交给内存池来处理了。这样出问题了，我们也可以从内存池那里先排查，更容易发现内存相关的问题。
**内存池实现不太容易，个人造内存相关的轮子容易出bug，企业级别的内存池更加有保障一些。比较出名的内存池有 jemalloc 和 tcmalloc，这两个都是全局内存池，比较推荐使用 tcmalloc。**
# 全局内存池还是局部内存池
如果现在有一个服务器，他时不时会接受新用户的连接。而我们将实现一个内存池用于管理内存，我们应该考虑将内存池设计成全局还是非全局形式。

1. 使用一个全局内存池，这样实现比较困难。对于内存块的回收更是令人头疼（我们从内存池分配出来的内存），好在我们可以使用jemalloc/tcmalloc
2. 针对每一个连接建立一个内存池，连接销毁释放内存池。这种情况下，这个内存池的生命周期就和这个连接的生命周期是一样的了。我们就不考虑小块的回收问题了。
# 内存池设计思想
这里参照 Nginx 的内存池设计思想，Nginx 内存池设计思路精巧简单，没有那么复杂。Nginx 每收到一个请求，就创建一个内存池给新连接使用，请求处理完成后释放内存池，因此内存池并非是单例模式的。
Ngin 将内存分为大块内存和小块内存来管理，对于小块内存，用户申请后不需要主动释放，而是等待释放内存池时再释放。对于大块内存，用户可以调用相关接口进行释放，也可以等内存池释放时再释放。因此，Nginx 对于小块内存的回收并不是很在意。
同时 Nginx 内存池支持增加回调函数，当内存池释放时，自动调用回调函数释放用户申请的资源。回调函数允许增加多个，通过链表进行链接，在内存池释放时被逐一调用。
Nginx 创建内存池会先申请 PAGE_SIZE 内存，我称为 block。一部分用来容纳 ngx_pool_t 结构体，另一部分内存则是用于满足用户申请。ngx_pool_data_t 结构体中的 last 指针和 end 指针之间的内存是空闲的，当用户申请小块内存时，如果空闲的内存大小满足用户的需求，则可以分配给用户。
## 管理内存块的结点
![1669112895386.png](https://cdn.nlark.com/yuque/0/2022/png/26752078/1669112902652-afae0f9d-d616-435f-b40d-540c1b055bc9.png#averageHue=%23fcf0ca&clientId=u8e162442-b6f3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=600&id=ucea5d58c&margin=%5Bobject%20Object%5D&name=1669112895386.png&originHeight=750&originWidth=1151&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35521&status=done&style=none&taskId=u46ccc8da-09b7-4970-98dc-ab02aaad40c&title=&width=920.8)